pipeline {
    agent any

    environment {
        GITHUB_REPO            = "https://github.com/Khalil0010/Administration.git"
        DOCKER_REGISTRY        = "aziz244"
        IMAGE_TAG              = "1.0"
        NAMESPACE              = "savewise"
        TRIVY_PATH             = "${WORKSPACE}\\trivy-bin\\trivy.exe"
        MINIKUBE_BIN_PATH      = "${WORKSPACE}\\minikube-bin"
    }

    options {
        timestamps()
        buildDiscarder(logRotator(numToKeepStr: '10'))
    }

    stages {
        stage('Clone Repository') {
            steps {
                git branch: 'main', url: "${GITHUB_REPO}"
            }
        }

        stage('Prepare Trivy') {
            steps {
                script {
                    // Check if Trivy already exists
                    def trivyExists = bat(script: '@if exist "%WORKSPACE%\\trivy-bin\\trivy.exe" (echo YES) else (echo NO)', returnStdout: true).trim()
                    
                    if (trivyExists.contains('NO')) {
                        echo "Trivy not found, downloading and installing..."
                        bat '''
                            @echo off
                            if exist trivy-bin rmdir /s /q trivy-bin
                            mkdir trivy-bin
                            cd trivy-bin
                            
                            echo Downloading Trivy...
                            curl -Lo trivy.zip https://github.com/aquasecurity/trivy/releases/download/v0.48.0/trivy_0.48.0_Windows-64bit.zip
                            
                            if not exist trivy.zip (
                                echo ERROR: Failed to download Trivy!
                                exit /b 1
                            )
                            
                            echo Extracting Trivy...
                            tar -xf trivy.zip
                            del trivy.zip
                            
                            if not exist trivy.exe (
                                echo ERROR: trivy.exe not found after extraction!
                                exit /b 1
                            )
                            
                            echo Trivy installed successfully!
                            trivy.exe --version
                        '''
                    } else {
                        echo "Trivy already installed at ${WORKSPACE}\\trivy-bin\\trivy.exe"
                        bat "\"${WORKSPACE}\\trivy-bin\\trivy.exe\" --version"
                    }
                }
            }
        }

        // ========== BUILD STAGES ==========
        stage('Build: Analytics Service') {
            steps {
                dir('analytics-service') {
                    bat "docker build -t ${DOCKER_REGISTRY}/analytics-service:${IMAGE_TAG} ."
                }
            }
        }

        stage('Build: Auth Service') {
            steps {
                dir('auth-service') {
                    bat "docker build -t ${DOCKER_REGISTRY}/auth-service:${IMAGE_TAG} ."
                }
            }
        }

        stage('Build: Budget Service') {
            steps {
                dir('budget-service') {
                    bat "docker build -t ${DOCKER_REGISTRY}/budget-service:${IMAGE_TAG} ."
                }
            }
        }

        stage('Build: Frontend') {
            steps {
                dir('frontend') {
                    bat "docker build -t ${DOCKER_REGISTRY}/frontend:${IMAGE_TAG} ."
                }
            }
        }

        stage('Build: Notification Service') {
            steps {
                dir('notification-service') {
                    bat "docker build -t ${DOCKER_REGISTRY}/notification-service:${IMAGE_TAG} ."
                }
            }
        }

        stage('Build: Saving Goals Service') {
            steps {
                dir('saving-goals-service') {
                    bat "docker build -t ${DOCKER_REGISTRY}/saving-goals-service:${IMAGE_TAG} ."
                }
            }
        }

        stage('Build: Transaction Service') {
            steps {
                dir('transaction-service') {
                    bat "docker build -t ${DOCKER_REGISTRY}/transaction-service:${IMAGE_TAG} ."
                }
            }
        }

        stage('Build: User Service') {
            steps {
                dir('user-service') {
                    bat "docker build -t ${DOCKER_REGISTRY}/user-service:${IMAGE_TAG} ."
                }
            }
        }

        // ========== TRIVY SCAN STAGES ==========
        stage('Scan: Analytics Service') {
            steps {
                script {
                    echo "Scanning analytics-service..."
                    def scanStatus = bat(script: """
                        @echo off
                        "${TRIVY_PATH}" image --exit-code 1 --no-progress --severity HIGH,CRITICAL ${DOCKER_REGISTRY}/analytics-service:${IMAGE_TAG}
                    """, returnStatus: true)
                    
                    if (scanStatus != 0) {
                        echo "‚ö†Ô∏è Trivy found HIGH or CRITICAL vulnerabilities in analytics-service"
                        // Uncomment the next line to fail the pipeline on vulnerabilities
                        // error("Trivy scan failed for analytics-service")
                    } else {
                        echo "‚úÖ Trivy scan completed for analytics-service - No HIGH/CRITICAL vulnerabilities"
                    }
                }
            }
        }

        stage('Scan: Auth Service') {
            steps {
                script {
                    echo "Scanning auth-service..."
                    def scanStatus = bat(script: """
                        @echo off
                        "${TRIVY_PATH}" image --exit-code 1 --no-progress --severity HIGH,CRITICAL ${DOCKER_REGISTRY}/auth-service:${IMAGE_TAG}
                    """, returnStatus: true)
                    
                    if (scanStatus != 0) {
                        echo "‚ö†Ô∏è Trivy found HIGH or CRITICAL vulnerabilities in auth-service"
                    } else {
                        echo "‚úÖ Trivy scan completed for auth-service - No HIGH/CRITICAL vulnerabilities"
                    }
                }
            }
        }

        stage('Scan: Budget Service') {
            steps {
                script {
                    echo "Scanning budget-service..."
                    def scanStatus = bat(script: """
                        @echo off
                        "${TRIVY_PATH}" image --exit-code 1 --no-progress --severity HIGH,CRITICAL ${DOCKER_REGISTRY}/budget-service:${IMAGE_TAG}
                    """, returnStatus: true)
                    
                    if (scanStatus != 0) {
                        echo "‚ö†Ô∏è Trivy found HIGH or CRITICAL vulnerabilities in budget-service"
                    } else {
                        echo "‚úÖ Trivy scan completed for budget-service - No HIGH/CRITICAL vulnerabilities"
                    }
                }
            }
        }

        stage('Scan: Frontend') {
            steps {
                script {
                    echo "Scanning frontend..."
                    def scanStatus = bat(script: """
                        @echo off
                        "${TRIVY_PATH}" image --exit-code 1 --no-progress --severity HIGH,CRITICAL ${DOCKER_REGISTRY}/frontend:${IMAGE_TAG}
                    """, returnStatus: true)
                    
                    if (scanStatus != 0) {
                        echo "‚ö†Ô∏è Trivy found HIGH or CRITICAL vulnerabilities in frontend"
                    } else {
                        echo "‚úÖ Trivy scan completed for frontend - No HIGH/CRITICAL vulnerabilities"
                    }
                }
            }
        }

        stage('Scan: Notification Service') {
            steps {
                script {
                    echo "Scanning notification-service..."
                    def scanStatus = bat(script: """
                        @echo off
                        "${TRIVY_PATH}" image --exit-code 1 --no-progress --severity HIGH,CRITICAL ${DOCKER_REGISTRY}/notification-service:${IMAGE_TAG}
                    """, returnStatus: true)
                    
                    if (scanStatus != 0) {
                        echo "‚ö†Ô∏è Trivy found HIGH or CRITICAL vulnerabilities in notification-service"
                    } else {
                        echo "‚úÖ Trivy scan completed for notification-service - No HIGH/CRITICAL vulnerabilities"
                    }
                }
            }
        }

        stage('Scan: Saving Goals Service') {
            steps {
                script {
                    echo "Scanning saving-goals-service..."
                    def scanStatus = bat(script: """
                        @echo off
                        "${TRIVY_PATH}" image --exit-code 1 --no-progress --severity HIGH,CRITICAL ${DOCKER_REGISTRY}/saving-goals-service:${IMAGE_TAG}
                    """, returnStatus: true)
                    
                    if (scanStatus != 0) {
                        echo "‚ö†Ô∏è Trivy found HIGH or CRITICAL vulnerabilities in saving-goals-service"
                    } else {
                        echo "‚úÖ Trivy scan completed for saving-goals-service - No HIGH/CRITICAL vulnerabilities"
                    }
                }
            }
        }

        stage('Scan: Transaction Service') {
            steps {
                script {
                    echo "Scanning transaction-service..."
                    def scanStatus = bat(script: """
                        @echo off
                        "${TRIVY_PATH}" image --exit-code 1 --no-progress --severity HIGH,CRITICAL ${DOCKER_REGISTRY}/transaction-service:${IMAGE_TAG}
                    """, returnStatus: true)
                    
                    if (scanStatus != 0) {
                        echo "‚ö†Ô∏è Trivy found HIGH or CRITICAL vulnerabilities in transaction-service"
                    } else {
                        echo "‚úÖ Trivy scan completed for transaction-service - No HIGH/CRITICAL vulnerabilities"
                    }
                }
            }
        }

        stage('Scan: User Service') {
            steps {
                script {
                    echo "Scanning user-service..."
                    def scanStatus = bat(script: """
                        @echo off
                        "${TRIVY_PATH}" image --exit-code 1 --no-progress --severity HIGH,CRITICAL ${DOCKER_REGISTRY}/user-service:${IMAGE_TAG}
                    """, returnStatus: true)
                    
                    if (scanStatus != 0) {
                        echo "‚ö†Ô∏è Trivy found HIGH or CRITICAL vulnerabilities in user-service"
                    } else {
                        echo "‚úÖ Trivy scan completed for user-service - No HIGH/CRITICAL vulnerabilities"
                    }
                }
            }
        }

        // ========== PUSH STAGES ==========
        stage('Push: Analytics Service') {
            steps {
                bat "docker push ${DOCKER_REGISTRY}/analytics-service:${IMAGE_TAG}"
            }
        }

        stage('Push: Auth Service') {
            steps {
                bat "docker push ${DOCKER_REGISTRY}/auth-service:${IMAGE_TAG}"
            }
        }

        stage('Push: Budget Service') {
            steps {
                bat "docker push ${DOCKER_REGISTRY}/budget-service:${IMAGE_TAG}"
            }
        }

        stage('Push: Frontend') {
            steps {
                bat "docker push ${DOCKER_REGISTRY}/frontend:${IMAGE_TAG}"
            }
        }

        stage('Push: Notification Service') {
            steps {
                bat "docker push ${DOCKER_REGISTRY}/notification-service:${IMAGE_TAG}"
            }
        }

        stage('Push: Saving Goals Service') {
            steps {
                bat "docker push ${DOCKER_REGISTRY}/saving-goals-service:${IMAGE_TAG}"
            }
        }

        stage('Push: Transaction Service') {
            steps {
                bat "docker push ${DOCKER_REGISTRY}/transaction-service:${IMAGE_TAG}"
            }
        }

        stage('Push: User Service') {
            steps {
                bat "docker push ${DOCKER_REGISTRY}/user-service:${IMAGE_TAG}"
            }
        }

        // ========== SETUP MINIKUBE ==========
        stage('Setup Minikube') {
            steps {
                script {
                    // First, check if Minikube is installed and accessible
                    def minikubeExists = bat(script: '''
                        @echo off
                        where minikube >nul 2>nul
                        if %ERRORLEVEL% equ 0 (echo YES) else (echo NO)
                    ''', returnStdout: true).trim()
                    
                    if (minikubeExists.contains('NO')) {
                        echo "Minikube not found, downloading and installing..."
                        bat '''
                            @echo off
                            if exist minikube-bin rmdir /s /q minikube-bin
                            mkdir minikube-bin
                            cd minikube-bin
                            
                            echo Downloading Minikube...
                            curl -Lo minikube.exe https://storage.googleapis.com/minikube/releases/latest/minikube-windows-amd64.exe
                            
                            if not exist minikube.exe (
                                echo ERROR: Failed to download Minikube!
                                exit /b 1
                            )
                            
                            echo Minikube installed successfully!
                            minikube.exe version
                        '''
                    } else {
                        echo "Minikube already installed."
                        bat "minikube version"
                    }
                    
                    // Add Minikube bin to PATH for this pipeline
                    env.PATH = "${MINIKUBE_BIN_PATH};${env.PATH}"
                    
                    echo "Checking Minikube health..."
                    
                    // Run minikube status, capture output and exit code without failing on non-zero
                    bat '''
                        @echo off
                        minikube status > "%WORKSPACE%\\minikube_status.txt" 2>&1
                        echo %ERRORLEVEL% > "%WORKSPACE%\\minikube_exitcode.txt"
                    '''
                    
                    // Read the captured files
                    def statusInfo = readFile('minikube_status.txt').trim()
                    def exitCode = readFile('minikube_exitcode.txt').trim().toInteger()
                    
                    echo "Minikube status exit code: ${exitCode}"
                    echo "Current Status: ${statusInfo}"
                    
                    if (statusInfo.contains('Stopped') || statusInfo.contains('Error') || !statusInfo.contains('host: Running')) {
                        echo "‚ö†Ô∏è Minikube is in a bad state or stopped. Resetting..."
                        bat "minikube delete"
                        
                        echo "Starting Minikube fresh..."
                        bat "minikube start --driver=docker --cpus=2 --memory=2048 --wait=all"
                    } else {
                        echo "‚úÖ Minikube is healthy."
                    }
                    
                    // Helpful for debugging if it fails again
                    bat "minikube kubectl -- get nodes"
                    bat "minikube kubectl -- create namespace ${NAMESPACE} --dry-run=client -o yaml | minikube kubectl -- apply -f -"
                }
            }
        }

        // ========== LOAD IMAGES TO MINIKUBE ==========
        stage('Load Images to Minikube') {
            steps {
                script {
                    echo "Loading Docker images into Minikube..."
                    def services = [
                        'analytics-service', 'auth-service', 'budget-service',
                        'frontend', 'notification-service', 'saving-goals-service',
                        'transaction-service', 'user-service'
                    ]
                    services.each { svc ->
                        bat "minikube image load ${DOCKER_REGISTRY}/${svc}:${IMAGE_TAG}"
                        echo "‚úÖ Loaded ${svc} into Minikube"
                    }
                }
            }
        }

        // ========== KUBERNETES DEPLOYMENT ==========
        stage('Deploy to Kubernetes') {
            steps {
                script {
                    echo "Deploying all services to Kubernetes..."
                    bat "minikube kubectl -- apply -f k8s/ -R -n ${NAMESPACE}"
                    echo "‚úÖ All Kubernetes resources deployed successfully"
                }
            }
        }

        stage('Wait for Deployments') {
            steps {
                script {
                    echo "Waiting for deployments to be ready..."
                    bat "minikube kubectl -- wait --for=condition=available --timeout=300s deployment --all -n ${NAMESPACE}"
                    echo "‚úÖ All deployments are ready"
                }
            }
        }

        // ========== SMOKE TESTS ==========
        stage('Verify Services') {
            steps {
                script {
                    echo "Verifying all services are running..."
                    bat "minikube kubectl -- get pods -n ${NAMESPACE}"
                    bat "minikube kubectl -- get services -n ${NAMESPACE}"
                }
            }
        }

        stage('Smoke Test: Auth Service') {
            steps {
                script {
                    def testStatus = bat(script: """
                        @echo off
                        minikube kubectl -- run test-auth --image=curlimages/curl:latest --rm -i --restart=Never -n ${NAMESPACE} -- curl -sSf --max-time 10 http://auth-service:8000/health
                    """, returnStatus: true)
                    
                    if (testStatus == 0) {
                        echo "‚úÖ auth-service is healthy"
                    } else {
                        echo "‚ö†Ô∏è auth-service health check failed"
                    }
                }
            }
        }

        stage('Smoke Test: User Service') {
            steps {
                script {
                    def testStatus = bat(script: """
                        @echo off
                        minikube kubectl -- run test-user --image=curlimages/curl:latest --rm -i --restart=Never -n ${NAMESPACE} -- curl -sSf --max-time 10 http://user-service:8001/health
                    """, returnStatus: true)
                    
                    if (testStatus == 0) {
                        echo "‚úÖ user-service is healthy"
                    } else {
                        echo "‚ö†Ô∏è user-service health check failed"
                    }
                }
            }
        }

        stage('Smoke Test: Transaction Service') {
            steps {
                script {
                    def testStatus = bat(script: """
                        @echo off
                        minikube kubectl -- run test-transaction --image=curlimages/curl:latest --rm -i --restart=Never -n ${NAMESPACE} -- curl -sSf --max-time 10 http://transaction-service:8002/health
                    """, returnStatus: true)
                    
                    if (testStatus == 0) {
                        echo "‚úÖ transaction-service is healthy"
                    } else {
                        echo "‚ö†Ô∏è transaction-service health check failed"
                    }
                }
            }
        }

        stage('Smoke Test: Budget Service') {
            steps {
                script {
                    def testStatus = bat(script: """
                        @echo off
                        minikube kubectl -- run test-budget --image=curlimages/curl:latest --rm -i --restart=Never -n ${NAMESPACE} -- curl -sSf --max-time 10 http://budget-service:8003/health
                    """, returnStatus: true)
                    
                    if (testStatus == 0) {
                        echo "‚úÖ budget-service is healthy"
                    } else {
                        echo "‚ö†Ô∏è budget-service health check failed"
                    }
                }
            }
        }

        stage('Smoke Test: Saving Goals Service') {
            steps {
                script {
                    def testStatus = bat(script: """
                        @echo off
                        minikube kubectl -- run test-goals --image=curlimages/curl:latest --rm -i --restart=Never -n ${NAMESPACE} -- curl -sSf --max-time 10 http://saving-goals-service:8004/health
                    """, returnStatus: true)
                    
                    if (testStatus == 0) {
                        echo "‚úÖ saving-goals-service is healthy"
                    } else {
                        echo "‚ö†Ô∏è saving-goals-service health check failed"
                    }
                }
            }
        }

        stage('Smoke Test: Analytics Service') {
            steps {
                script {
                    def testStatus = bat(script: """
                        @echo off
                        minikube kubectl -- run test-analytics --image=curlimages/curl:latest --rm -i --restart=Never -n ${NAMESPACE} -- curl -sSf --max-time 10 http://analytics-service:8005/health
                    """, returnStatus: true)
                    
                    if (testStatus == 0) {
                        echo "‚úÖ analytics-service is healthy"
                    } else {
                        echo "‚ö†Ô∏è analytics-service health check failed"
                    }
                }
            }
        }

        stage('Smoke Test: Notification Service') {
            steps {
                script {
                    def testStatus = bat(script: """
                        @echo off
                        minikube kubectl -- run test-notification --image=curlimages/curl:latest --rm -i --restart=Never -n ${NAMESPACE} -- curl -sSf --max-time 10 http://notification-service:8006/health
                    """, returnStatus: true)
                    
                    if (testStatus == 0) {
                        echo "‚úÖ notification-service is healthy"
                    } else {
                        echo "‚ö†Ô∏è notification-service health check failed"
                    }
                }
            }
        }

        stage('Smoke Test: Frontend') {
            steps {
                script {
                    def testStatus = bat(script: """
                        @echo off
                        minikube kubectl -- run test-frontend --image=curlimages/curl:latest --rm -i --restart=Never -n ${NAMESPACE} -- curl -sSf --max-time 10 http://frontend:8501
                    """, returnStatus: true)
                    
                    if (testStatus == 0) {
                        echo "‚úÖ frontend is healthy"
                    } else {
                        echo "‚ö†Ô∏è frontend health check failed"
                    }
                }
            }
        }

        stage('Get Service URLs') {
            steps {
                script {
                    echo "Getting Minikube service URLs..."
                    bat "minikube service list -n ${NAMESPACE}"
                    echo """
                    ========================================
                    To access services locally, run:
                    minikube service frontend -n ${NAMESPACE}
                    ========================================
                    """
                }
            }
        }
    }

    post {
        success { echo "Pipeline succeeded! üöÄ" }
        failure { echo "Pipeline failed! Check logs. ‚ùå" }
    }
}